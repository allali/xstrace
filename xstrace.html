<!DOCTYPE html>
<html>
  <head>
    <style>
      #SVG{
	  width: 100%;
	  height: 100%;
      }
      
      #SVGdiv {
	  position: absolute;
	  top: 0;
	  left: 0;
	  right: 0;
	  bottom: 0;
      }
    </style>
      
<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.6.1/jquery.min.js"></script>
<script>
  var traces=[];
  var process={}
  var current=0;

  var pending_cb=[];

  function create_line(id,x1,y1,x2,y2){
      var newLine = document.createElementNS('http://www.w3.org/2000/svg','line');
      newLine.setAttribute('id',id);
      newLine.setAttribute('x1',x1);
      newLine.setAttribute('y1',y1);
      newLine.setAttribute('x2',x2);
      newLine.setAttribute('y2',y2);
      newLine.setAttribute('stroke',"black");
      return newLine;
  }
  
  function get(id){
      return $("#SVG")[0].contentDocument.getElementById(id);
  }

  
  function exec_sc(trace,prefix){
      console.log("exec cb: ",trace);
      // update binary
      var bin=trace['raw'].split('"')[1];
      get(prefix+"_BIN").innerHTML=bin;      
  }

  function open_sc(trace,prefix){
      var fd=trace['return']; 
      get(prefix+"_FD"+fd).style.fill="blue";
      // add line
      var f=get(prefix+"_FD"+fd).getBBox();
      var t=get(prefix+"_FD"+fd+"D").getBBox();
      var l=create_line(prefix+"fdl"+fd,f.x+f.width/2,f.y+f.height/2,t.x,t.y+t.height/2);
//      l.style.stroke="black";
      $("#SVG")[0].contentDocument.documentElement.append(l);
      // find free slote in file system:
      var i=0;
      while(i<=16 && get('K_F'+i).innerHTML!='') ++i;
      var fn=trace['raw'].split(',')[1]; // the filename
      get('K_F'+i).innerHTML=fn;
      var g=get('K_F'+i).getBBox();
      $("#SVG")[0].contentDocument.documentElement.append(create_line(prefix+"fdll"+fd,t.x+t.width,t.y+t.height/2,g.x,g.y+g.height/2));
      // TODO: add position and rights in second column
      var r='';
      if (trace['raw'].includes("O_RDWR")) r='RW';
      else if (trace['raw'].includes("O_RDONLY")) r='R';
      else if (trace['raw'].includes("O_WRONLY")) r='W';
      r=r+'/'+0; // 0 is the position in file
      get(prefix+"_FD"+fd+"DT").innerHTML=r;
  }

  
  function close_cb(trace,prefix){
      get(prefix+'_FD'+trace['args']).style.fill="none";
      get(prefix+'_FD'+trace['args']+'DT').innerHTML='';
      // remove lines
      var x=get(prefix+'fdl'+trace['args']);
      if (x!==null) x.remove();
      x=get(prefix+'fdll'+trace['args']);
      if (x!==null) x.remove();
  }

  function readwrite_cb(trace,prefix){
      var col="red";
      if (trace['sc'].includes('read'))  col="green";
      var fd=trace['args'].split(',')[0];
      var x=get(prefix+"_FD"+fd);      
      var l1=get(prefix+'fdl'+fd);
      var l2=get(prefix+'fdll'+fd);
      x.style.stroke=col;
      x.style.fill=col;
      if (l1) l1.style.stroke=col;
      if (l2) l2.style.stroke=col;
      pending_cb.push(function(){
	  x.style.stroke="black";
	  x.style.fill="blue";
	  if (l1) l1.style.stroke="black";
	  if (l2) l2.style.stroke="black";	  
      });
  }
  
  var sc_callback={'execve':exec_sc,'openat':open_sc,'close':close_cb,'read':readwrite_cb,'pread64':readwrite_cb,'write':readwrite_cb};

  function next_trace(){
      console.log("next trace");
      pending_cb.forEach(function(cb){cb();});
      pending_cb=[];
      if (current>=traces.length) return;
      console.log(traces[current]);
      var trace=traces[current];
      if (!(trace['pid'] in process)){ // this is a new process
	  process[trace['pid']]=new Object();
	  process[trace['pid']].id=Object.keys(process).length-1;
	  // set pid
	  get("P"+process[trace['pid']].id+"_PID").innerHTML=trace['pid'];
      }
      var prefix="P"+process[trace['pid']].id;
      // update current sys call
      var csc=get(prefix+"_CURRENT_SC");

      // show current process as the active one:
      get(prefix+"_BOX").style.stroke='red';
      pending_cb.push(function(){
	  get(prefix+"_BOX").style.stroke="black";
      });
      
      csc.innerHTML=trace['raw'].substr(0,30);
      get("CURRENT_TRACE").innerHTML=trace['raw'];
      if (trace['error']===null)
	  csc.style.fill='green';
      else
	  csc.style.fill='red';
      
      pending_cb.push(function(){ // remove text from current sc and add it to last sc
	  console.log("cb...");
	  var txt=csc.innerHTML;
	  for(var i=9;i>0;--i){
	      var a=get(prefix+"_LAST_SC"+i), b=get(prefix+"_LAST_SC"+(i-1));
	      a.innerHTML=b.innerHTML;
	      a.style.fill=b.style.fill;	      
	  }
	  var a=get(prefix+"_LAST_SC0");
	  a.innerHTML=txt;
	  a.style.fill=csc.style.fill;
	  csc.innerHTML="";
	  // get the position of a text box: t.children[0].getExtentOfChar(0)
	  // 
      });

      if (trace['error']===null){
	  if (trace['sc'] in sc_callback)  sc_callback[trace['sc']](trace,prefix);
      }
      
      current+=1;
  }

  function next_trace_ok(){
      next_trace();
      while ((current<traces.length) && (traces[current-1]['error']!==null)) next_trace();
      console.log(traces[current]);
  }

  function init_trace(){
      console.log("init trace");
      // Hide kernel stuff:
      for(var i=0;i<=16;++i)
	  get('K_F'+i).innerHTML=''; // open files
      // TODO: hide all process except P0
      get('P1').style.display="none";
      // for each process, hide text
      for(var p=0;p<1;p++){
	  for(var i=0;i<10;++i)
	      get('P'+p+'_LAST_SC'+i).innerHTML='';
	  for(var i=0;i<13;++i)
	      get('P'+p+'_FD'+i+'DT').innerHTML='';
      }
      next_trace(); // load first trace
  }


  
  $(document).ready(function () {

      $("body").keydown(function(e){
	  if (e.keyCode==39){
	      next_trace();
	  }
      });

      
    $('[type=file]').change(function () {
	if (!("files" in this)) {
            alert("File reading not supported in this browser");
        }
        var file = this.files && this.files[0];
        if (!file) {
            return;
        }
        var fileReader = new FileReader();
	
        fileReader.onload = function (e) {
            var text = e.target.result;
	    $("#tracefile").hide();
	    $("#intro").hide();
	    // parsing strace file....
	    line_re = RegExp("([^\\(]*)\\((.*)\\)\\ +=\\ (.*)$");
	    var lines=text.split('\n'),i;
	    for(i=0;i<lines.length;++i){
		var x=lines[i].indexOf(' ')
		if (x==-1) continue;
		pid=lines[i].substr(0,x);
		var raw=lines[i].substr(x+1)
		m=line_re.exec(raw);
		if (m=== null || m.length!=4){ console.log("skip:",m);}
		else {
		    var sc=m[1];
		    var args=m[2];
		    var rets=m[3];
		    var ret=rets,e=null;
		    var x=rets.indexOf(' ');
		    if (x!=-1) {
			ret=rets.substr(0,x);
			e=rets.substr(x+1);
		    }
		    console.log(m);
		    console.log(pid,sc,raw,"return:",ret,"error:",e);
		    traces.push({'pid':pid,'sc':sc,'raw':raw,'return':ret,'error':e,'args':args});
		}
	    }
	    console.log(traces);

	    $("#SVG").show({complete : function(){
		// From now, SVG is load, we can work on it....
		$("#SVG")[0].contentDocument.getElementById('next').onclick=next_trace;
		$("#SVG")[0].contentDocument.getElementById('next_ok').onclick=next_trace_ok;
		$("#SVG")[0]
		init_trace();
	    }});
        };
	
        fileReader.readAsText(this.files[0]);
    });
});
</script>
</head>
  <body>
    <div id="intro">
    <h1> xstrace </h1>
    <p> xstrace allows you to visualise syscall of a process graphically, it can be usefull for understanding
      syscall and debugging small programs.</p>
    <p> This tools only deals with a limited number of processus (ie. 4). </p>
    <p> Not all syscall are dealed (ie. graphically represented). This can lead to wrong/confusing/buggy graphical representation. </p>
    <p> To use this tool, juste upload a trace generated using <code>strace -f -o trace.log ./a.out</code> </p>
    <p> No data is transfert to a webserver: javascript will parse the log file and create visual, all in your browser </p>
    <p> fill free to submit improvements and/or to fork : this code is under beerware licence (see LICENCE file) :)</p>
    </div>
    
  <input id="tracefile" type="file">
  
  <div class="SVGdiv">
    <object id="SVG" data="xstrace.svg" type="image/svg+xml" style="display:none;"></object>
  </div>

</body>
</html>
